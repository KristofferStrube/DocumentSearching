@page "/"
@using System.Globalization
@using CsvHelper
@using CsvHelper.Configuration.Attributes
@using KristofferStrube.DocumentSearching.SuffixTree
@using System.Diagnostics
@using System.Text.RegularExpressions
@inject HttpClient HttpClient

<PageTitle>DocumentSearching - Search</PageTitle>

<h1>Search</h1>
<p>
    Here you can search through all the elements in the periodic table using an in-memory search index.<br />
    @if(index is null)
    {
        <small>The index is currently being built (@indexingProgress / @(elements?.Length-1)).</small>
    }
    else
    {
        <small>Try seaching "Hydrogen".</small>
    }
</p>
@if (index is null)
{
    return;
}
<input @bind=query @bind:event="oninput" @bind:after=Search style="width:100%;" />
<br />
@if (searchTime is not null && naive is not null)
{
    <p>Found @searchResults.Length @(searchResults.Length is 1 ? "element" : "elements") in @($"{searchTime.Value:0.0}") ms compared to a naive Regex search in @($"{naive.Value:0.0}") ms.</p>
}

@foreach (SearchResult<Element> result in searchResults)
{
    <div @key=result.Element>
        <h3>@result.Element.Name</h3>
        <p>@result.Element.Summary</p>
        <hr />
    </div>
}

@code {
    private double? searchTime;
    private double? naive;
    private Element[] elements = default!;
    private SearchResult<Element>[] searchResults = [];

    private DocumentIndex<Element, SuffixTreeSearchIndex>? index;
    private int indexingProgress = 0;

    private string query = "";

    protected override async Task OnInitializedAsync()
    {
        Stream periodicTableCsv = await HttpClient.GetStreamAsync("data/periodic-table-detailed.csv");
        using StreamReader streamReader = new StreamReader(periodicTableCsv);

        using var csv = new CsvReader(streamReader, CultureInfo.InvariantCulture);
        elements = csv.GetRecords<Element>().ToArray();

        index = await DocumentIndex<Element, SuffixTreeSearchIndex>.CreateAsync(elements, async e =>
        {
            indexingProgress++;
            StateHasChanged();
            await Task.Delay(1);
            return e.Summary.ToLower();
        });
        StateHasChanged();
        await Task.Delay(1);
    }

    public async Task Search()
    {
        if (query is "" || index is null)
        {
            searchResults = [];
            searchTime = null;
            return;
        }

        Stopwatch sw = Stopwatch.StartNew();
        searchResults = index.ExactSearch(query.ToLower());
        searchTime = sw.ElapsedTicks / (double)1_000_000;

        sw = Stopwatch.StartNew();
        Console.WriteLine(elements.Select(e => Regex.Matches(e.Name.ToLower() + " " + e.Summary.ToLower(), query.ToLower()).Cast<Match>().Select(m => m.Index).ToArray().Length).Sum());
        naive = sw.ElapsedTicks / (double)1_000_000;
    }

    public class Element
    {
        [Name("name")]
        public required string Name { get; set; }
        [Name("summary")]
        public required string Summary { get; set; }
    }
}